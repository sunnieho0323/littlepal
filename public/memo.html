<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Mailbox - Virtual Pet</title>

  <!-- Materialize CSS-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <link rel="stylesheet" href="css/memo.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body class="container">
  <h5 style="display:flex; align-items:center; justify-content:space-between; gap:12px">
    <span>Mailbox</span>
    <span id="unreadBadge" class="new badge" data-badge-caption="Unread">0</span>
  </h5>

  <!-- Filters -->
  <div class="row">
    <div class="input-field col s12 m6">
      <input id="search" type="text" placeholder="Search subject or body"/>
    </div>
    <div class="input-field col s6 m3">
      <select id="sort">
        <option value="createdAt:desc" selected>Newest</option>
        <option value="createdAt:asc">Oldest</option>
        <option value="subject:asc">Subject Aâ†’Z</option>
        <option value="subject:desc">Subject Zâ†’A</option>
      </select>
      <label>Sort</label>
    </div>
    <div class="input-field col s6 m3">
      <input id="label" type="text" placeholder="Label (optional)"/>
    </div>
  </div>
  <div class="row" style="margin-top:-12px">
    <label>
      <input type="checkbox" id="unreadOnly"/>
      <span>Unread only</span>
    </label>
    <label style="margin-left:16px;">
      <input type="checkbox" id="includeExpired"/>
      <span>Include expired</span>
    </label>
  </div>

  <!-- List toolbar -->
  <div class="list-toolbar">
    <div class="muted" id="listSummary">Loading...</div>
    <div>
      <a class="btn-small" id="btnClaimAll">Claim All</a>
      <a class="btn-small red" id="btnDeleteRead">Delete Read</a>
      <a class="btn modal-trigger" href="#createModal">New Memo</a>
    </div>
  </div>

  <!-- Two columns -->
  <div class="two-col">
    <div class="left-col">
      <div id="list"></div>
      <ul class="pagination center" style="margin-top:14px">
        <li id="prevLi" class="waves-effect"><a href="#!" id="prev">Prev</a></li>
        <li class="active"><a href="#!" id="pageNum">1</a></li>
        <li id="nextLi" class="waves-effect"><a href="#!" id="next">Next</a></li>
      </ul>
    </div>

    <div class="right-col" id="detailPanel">
      <p class="grey-text">Select a mail to view details</p>
    </div>
  </div>

  <!-- Create/Edit Modal -->
  <div id="createModal" class="modal">
    <div class="modal-content">
      <h5 id="modalTitle">New Memo</h5>
      <div class="input-field"><input id="to" placeholder="Recipient UserId (optional/for send)"/></div>
      <div class="input-field"><input id="subject" placeholder="Subject" required/></div>
      <div class="input-field"><textarea id="body" class="materialize-textarea" placeholder="Body"></textarea></div>
      <div class="input-field"><input id="labels" placeholder="Labels (comma separated)"/></div>
      <div class="input-field"><input id="expiresAt" type="datetime-local"/></div>
      <p>Attachment (one-time claim): <input id="attachmentJson" placeholder='{"type":"currency","payload":{"gold":100}}'/></p>
    </div>
    <div class="modal-footer">
      <a href="#!" id="btnSubmit" class="modal-close waves-effect waves-green btn">Submit</a>
    </div>
  </div>

 <!--materialize CSS-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<script>
  const API = (p)=> `/api${p}`;

  // Headers: JWT if present; else dev mock x-user-id
  function getHeaders() {
    const h = { 'Content-Type':'application/json' };
    const token = localStorage.getItem('jwt');
    if (token) h['Authorization'] = `Bearer ${token}`;
    if (window.DEMO_USER_ID) h['x-user-id'] = window.DEMO_USER_ID; // mock auth fallback
    return h;
  }

  let page = 1;
  let since = '1970-01-01T00:00:00.000Z'; // notifications polling cursor
  let listLoading = false;
  let lastUnread = 0;
  let unreadAbort; // AbortController for unread fetch

  document.addEventListener('DOMContentLoaded', async ()=>{
    M.FormSelect.init(document.querySelectorAll('select'), {});
    M.Modal.init(document.querySelectorAll('.modal'), {});
    await load();
    lastUnread = await refreshUnreadBadge(true);

    document.getElementById('search').addEventListener('input', debounce(load, 300));
    document.getElementById('sort').addEventListener('change', load);
    document.getElementById('label').addEventListener('input', debounce(load, 300));
    document.getElementById('unreadOnly').addEventListener('change', load);
    document.getElementById('includeExpired').addEventListener('change', load);
    document.getElementById('btnClaimAll').onclick = claimAll;
    document.getElementById('btnDeleteRead').onclick = deleteRead;

    document.getElementById('prev').onclick = ()=> {
      if (document.getElementById('prevLi').classList.contains('disabled')) return;
      if (page > 1) { page--; load(); }
    };
    document.getElementById('next').onclick = ()=> {
      if (document.getElementById('nextLi').classList.contains('disabled')) return;
      page++; load();
    };
    document.getElementById('btnSubmit').onclick = submitMemo;

    // polling notifications (push style refresh)
    setInterval(pollNotifs, 4000);

    // unread heartbeat
    setInterval(() => refreshUnreadBadge(true), 3000);

    window.addEventListener('focus', () => { refreshUnreadBadge(true); });
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) refreshUnreadBadge(true);
    });
  });

  async function load() {
    if (listLoading) return;
    listLoading = true;

    const list = document.getElementById('list');
    const listSummary = document.getElementById('listSummary');
    list.innerHTML = `<p class="grey-text">Loading...</p>`;

    const showEmpty = () => { 
      list.innerHTML = `<p class="grey-text">No data</p>`;
      if (listSummary) listSummary.textContent = `Page ${page} â€¢ 0 items`;
    };
    const showFail  = (msg='Failed to load.') => { 
      list.innerHTML = `<p class="grey-text">${msg}</p>`;
      if (listSummary) listSummary.textContent = `Page ${page}`;
    };

    try {
      const q = buildQuery(page, 10);
      const res = await fetch(API(`/memos?${q.toString()}`), { headers: getHeaders() });

      // 204/404 è¦–ç‚ºã€Œæ²’æœ‰è³‡æ–™ã€è€Œä¸æ˜¯éŒ¯èª¤
      if (res.status === 204 || res.status === 404) {
        document.getElementById('pageNum').textContent = String(page);
        const prevLi = document.getElementById('prevLi');
        const nextLi = document.getElementById('nextLi');
        if (prevLi) prevLi.classList.add('disabled');
        if (nextLi) nextLi.classList.add('disabled');
        showEmpty();
        return;
      }

      if (!res.ok) {
        const txt = await res.text().catch(()=> '');
        showFail(`Failed to load. (${res.status}) ${txt.slice(0,80)}`);
        return;
      }

      // è§£æ JSONï¼›è‹¥å›ç©ºå­—ä¸²ï¼Œä¹Ÿä¸æœƒç‚¸
      const json = await res.json().catch(()=> ({}));
      const items = json.data || json.items || [];
      const pageInfo = json.pageInfo || json.meta || { page, pageSize: 10, total: items.length, hasNext: false };

      // ç©ºçµæœ â†’ æ­£å¸¸ã€ŒNo dataã€
      if (!items || items.length === 0 || Number(pageInfo.total) === 0) {
        document.getElementById('pageNum').textContent = String(pageInfo.page || page);
        const prevLi = document.getElementById('prevLi');
        const nextLi = document.getElementById('nextLi');
        if (prevLi) prevLi.classList.add('disabled');
        if (nextLi) nextLi.classList.add('disabled');
        showEmpty();
        return;
      }

      // æœ‰è³‡æ–™ â†’ æ­£å¸¸æ¸²æŸ“ + åˆ†é ç‹€æ…‹
      document.getElementById('pageNum').textContent = pageInfo.page;
      const prevLi = document.getElementById('prevLi') || document.getElementById('prev')?.parentElement;
      const nextLi = document.getElementById('nextLi') || document.getElementById('next')?.parentElement;
      if (prevLi) prevLi.classList.toggle('disabled', (pageInfo.page || 1) <= 1);
      if (nextLi) nextLi.classList.toggle('disabled', !pageInfo.hasNext);

      if (listSummary) listSummary.textContent = `Page ${pageInfo.page} â€¢ ${items.length} items`;
      renderList(items);
    } catch (e) {
      showFail();
    } finally {
      listLoading = false;
    }
  }


  async function fetchUnreadTotal() {
    try {
      if (unreadAbort) unreadAbort.abort();
      unreadAbort = new AbortController();

      const candidates = [
        '/memos?unread=true&limit=1&page=1',
        '/memos?status=unread&limit=1&page=1'
      ];
      for (const path of candidates) {
        const res = await fetch(API(path), { headers: getHeaders(), signal: unreadAbort.signal });
        if (!res.ok) continue;
        const json = await res.json().catch(()=>({}));
        const total = json?.counts?.unread ?? json?.pageInfo?.total ?? json?.meta?.total ?? json?.total ?? 0;
        const n = Number(total);
        if (!Number.isNaN(n)) return n;
      }
    } catch(_) {}
    return 0;
  }

  async function refreshUnreadBadge(changeAware = false) {
    const total = await fetchUnreadTotal();
    updateUnreadBadge(total);
    if (changeAware && total !== lastUnread) {
      lastUnread = total;
      await load(); 
    }
    return total;
  }
  
  function buildQuery(pageNum, size){
    const q = new URLSearchParams();
    q.set('page', pageNum);
    q.set('pageSize', size);         // ä½ çš„å¾Œç«¯è‹¥ç”¨ limitï¼Œä¹Ÿå¯åŠ  q.set('limit', size);

    const search = document.getElementById('search').value.trim();
    if (search) q.set('q', search);

    const label = document.getElementById('label').value.trim();
    const [sortKey, order] = document.getElementById('sort').value.split(':');
    const unreadOnly = document.getElementById('unreadOnly').checked;
    const includeExpired = document.getElementById('includeExpired').checked;

    if (label) q.set('label', label);
    if (unreadOnly) q.set('unread','true');     // è‹¥å¾Œç«¯åªåƒ status=unreadï¼Œæ”¹æˆï¼šq.set('status','unread');
    if (includeExpired) q.set('includeExpired','true');
    q.set('sort', sortKey);
    q.set('order', order);
    return q;
  }

  let selectedId = null;

  function renderList(items) {
    const list = document.getElementById('list');
    if (!items.length) { list.innerHTML = `<p class="grey-text">No data</p>`; return; }
    list.innerHTML = items.map(m => {
      const isUnread = (m.status === 'unread') || (m.unread === true);
      const labels = Array.isArray(m.labels) ? m.labels : (m.label ? [m.label] : []);
      const expired = m.expiresAt && new Date(m.expiresAt).getTime() <= Date.now();
      const claimed = !!(m.claimedAt || m.claimedBy || (m.attachments && m.attachments.claimed === true));
      const hasAttachment = Array.isArray(m.attachments) ? m.attachments.length > 0 : !!m.attachments;

      return `
        <div class="memo-row ${selectedId===m._id?'selected':''}" onclick="openMemo('${m._id}', this)">
          <div class="left">
            <span class="badge ${isUnread ? 'new':''}" data-badge-caption="${isUnread?'Unread':'Read'}"></span>
            <span class="subject">${escapeHtml(m.subject)}</span>
            <div class="preview">${escapeHtml((m.body||'').slice(0, 80))}${(m.body||'').length>80?'...':''}</div>
            <div class="badges">
              ${labels.map(lb => `<span class="new badge" data-badge-caption="${escapeHtml(lb)}"></span>`).join('')}
              ${m.expiresAt ? `<span class="badge" data-badge-caption="exp:${new Date(m.expiresAt).toLocaleString()}"></span>`:''}
              ${hasAttachment ? `<span class="badge" data-badge-caption="${claimed ? 'claimed' : (expired ? 'expired' : 'gift')}"></span>` : ''}
            </div>
          </div>
          <div>
            <a class="btn-flat">Open</a>
            ${renderClaimBtn(m)}
          </div>
        </div>
      `;
    }).join('');
  }

  function renderClaimBtn(m) {
    const now = Date.now();
    const expired = m.expiresAt && new Date(m.expiresAt).getTime() <= now;
    const hasAttachment = Array.isArray(m.attachments) ? m.attachments.length > 0 : !!m.attachments;
    const claimed = !!(m.claimedAt || m.claimedBy || (m.attachments && m.attachments.claimed === true));
    if (!hasAttachment) return '';
    if (expired) return `<a class="btn disabled">Expired</a>`;
    if (claimed) return `<a class="btn disabled">Claimed</a>`;
    return `<a class="btn" onclick="claim('${m._id}', this)">Claim</a>`;
  }

  function updateUnreadBadge(n) {
    const el = document.getElementById('unreadBadge');
    if (el) el.textContent = String(n ?? 0);
  }

  async function openMemo(id, rowEl) {
    selectedId = id;
    // å·¦æ¬„é¸å–æ¨£å¼
    Array.from(document.querySelectorAll('.memo-row')).forEach(el=> el.classList.remove('selected'));
    if (rowEl) rowEl.classList.add('selected');

    const res = await fetch(API(`/memos/${id}`), { headers: getHeaders() });
    const m = await res.json().catch(()=>null);
    if (!res.ok || !m) { M.toast({ html: 'Failed to open memo' }); return; }

    const isUnread = (m.status === 'unread') || (m.unread === true);
    const claimed = !!(m.claimedAt || m.claimedBy || (m.attachments && m.attachments.claimed === true));
    const expired = m.expiresAt && new Date(m.expiresAt).getTime() <= Date.now();
    const hasAttachment = Array.isArray(m.attachments) ? m.attachments.length > 0 : !!m.attachments;

    const panel = document.getElementById('detailPanel');
    if (panel) {
      panel.innerHTML = `
        <h6>${escapeHtml(m.subject)}</h6>
        <div class="muted" style="margin-top:-4px">${new Date(m.createdAt || m.updatedAt || Date.now()).toLocaleString()}</div>
        ${isUnread ? `<div style="margin:6px 0"><span class="new badge" data-badge-caption="Unread"></span></div>` : ''}
        <p style="white-space:pre-wrap; margin-top:8px">${escapeHtml(m.body || '')}</p>

        <div class="attachment-icons" id="attachments"></div>

        <div style="display:flex; gap:8px; margin-top:16px">
          <a class="btn red" onclick="deleteMemo('${m._id}')">Delete</a>
          ${
            hasAttachment
              ? (expired ? `<a class="btn disabled">Expired</a>`
                : (claimed ? `<a class="btn disabled">Claimed</a>`
                : `<a class="btn" id="detailClaimBtn" onclick="claim('${m._id}', this)">Claim</a>`))
              : `<span class="muted">No attachment</span>`
          }
        </div>
      `;
      renderAttachmentIcons(m.attachments);
    }

    // ä½ åŸæœ¬æœƒé å¾Œç«¯/é‡æ–°è¼‰å…¥ä¾†æ¨™å·²è®€ï¼›ä¿ç•™æœªè®€åˆ·æ–°
    await refreshUnreadBadge(true);
  }

  async function claim(id, btnEl) {
    try {

      if (btnEl) {
        btnEl.classList.add('disabled');
        btnEl.textContent = 'Claiming...';
      }

      const res = await fetch(API(`/memos/${id}/claim`), { method:'POST', headers: getHeaders() });
      const data = await res.json().catch(()=> ({}));

      if (res.ok) {
        M.toast({ html: 'Claim successful!' });

        if (btnEl) {
          btnEl.textContent = 'Claimed';
          btnEl.classList.add('disabled');
          btnEl.onclick = null;
        }
      } else {

        const code = data.code || res.status;
        M.toast({ html: `Failed: ${code}` });

        if (btnEl) {
          if (code === 409) { // already claimed
            btnEl.textContent = 'Claimed';
            btnEl.classList.add('disabled');
            btnEl.onclick = null;
          } else if (code === 410 || code === 400) { // expired
            btnEl.textContent = 'Expired';
            btnEl.classList.add('disabled');
            btnEl.onclick = null;
          } else {
            btnEl.textContent = 'Claim';
            btnEl.classList.remove('disabled');
          }
        }
      }
    } catch (_) {
      if (btnEl) {
        btnEl.textContent = 'Claim';
        btnEl.classList.remove('disabled');
      }
    } finally {

      await load();
    }
  }

  async function submitMemo() {
    const to = document.getElementById('to').value.trim();
    const subject = document.getElementById('subject').value.trim();
    const bodyText = document.getElementById('body').value.trim();
    const labelsArr = document.getElementById('labels').value.split(',').map(s=>s.trim()).filter(Boolean);
    const expiresVal = document.getElementById('expiresAt').value;
    const attOne = parseJsonOrNull(document.getElementById('attachmentJson').value);
    const attachments = attOne ? (Array.isArray(attOne) ? attOne : [attOne]) : []; 

    const payload = {
      recipientId: to || undefined, 
      subject,
      body: bodyText,
      labels: labelsArr.length ? labelsArr : ['inbox'],
      attachments,
      expiresAt: expiresVal ? new Date(expiresVal).toISOString() : null
    };

    const endpoint = to ? '/memos/send' : '/memos';
    const res = await fetch(API(endpoint), { method:'POST', headers: getHeaders(), body: JSON.stringify(payload) });
    const data = await res.json().catch(()=> ({}));
    if (res.ok) {
      M.toast({ html: 'Created!' });
      page = 1;
      await refreshUnreadBadge(true);
    } else {
      M.toast({ html: `Error: ${data.message || data.code || 'Failed to create memo'}` });
    }
  }

  async function pollNotifs() {
    try {
      const res = await fetch(API(`/notifications?since=${encodeURIComponent(since)}`), { headers: getHeaders() });
      if (!res.ok) return;
      const json = await res.json();
      const items = json.data || json.items || [];
      if (items.length) {
        since = items[items.length - 1].createdAt || since;
        
        refreshUnreadBadge(true);
      }
    } catch (_) {}
  }

  function renderDetailPlaceholder(){
    const panel = document.getElementById('detailPanel');
    if (panel) panel.innerHTML = `<p class="grey-text">Select a mail to view details</p>`;
  }

  function renderAttachmentIcons(att){
    const el = document.getElementById('attachments');
    if (!el) return;
    if (!att) { el.innerHTML = `<span class="muted">No attachments</span>`; return; }

    const chips = [];
    const pushChip = (icon, text) => chips.push(`<span class="attachment-chip">${icon} ${escapeHtml(text)}</span>`);

    if (Array.isArray(att)) {
      att.forEach(a=>{
        const t = (a.type || '').toLowerCase();
        if (t === 'currency' && a.payload) {
          for (const k of Object.keys(a.payload)) {
            const v = a.payload[k];
            if (k.toLowerCase().includes('gold') || k.toLowerCase().includes('coin')) pushChip('ğŸª™', `+${v}`);
            else if (k.toLowerCase().includes('gem') || k.toLowerCase().includes('diamond')) pushChip('ğŸ’', `+${v}`);
            else pushChip('ğŸ', `${k}: +${v}`);
          }
        } else if (t === 'item' && a.payload) {
          pushChip('ğŸ“¦', `${a.payload.name || 'Item'} Ã—${a.payload.qty || 1}`);
        } else {
          pushChip('ğŸ', JSON.stringify(a.payload ?? a));
        }
      });
    } else if (typeof att === 'object') {
      for (const k of Object.keys(att)) {
        const v = att[k];
        if (k.toLowerCase().includes('gold') || k.toLowerCase().includes('coin')) pushChip('ğŸª™', `+${v}`);
        else if (k.toLowerCase().includes('gem') || k.toLowerCase().includes('diamond')) pushChip('ğŸ’', `+${v}`);
        else pushChip('ğŸ', `${k}: +${v}`);
      }
    } else {
      pushChip('ğŸ', String(att));
    }
    el.innerHTML = chips.join('');
  }

  async function deleteMemo(id){
    const res = await fetch(API(`/memos/${id}`), { method:'DELETE', headers: getHeaders() });
    if (res.ok) {
      M.toast({ html: 'Deleted.' });
      if (selectedId === id) { selectedId = null; renderDetailPlaceholder(); }
      await refreshUnreadBadge(true);
    } else {
      M.toast({ html: 'Delete failed' });
    }
  }

  // å…ˆè©¦å¾Œç«¯ bulkï¼Œæ²’æœ‰å°± fallback é€ä¸€è™•ç†ï¼ˆä¾ç›®å‰ç¯©é¸æ¢ä»¶åˆ†é æŠ“ï¼‰
  async function claimAll(){
    try {
      const r = await fetch(API('/memos/claim-all'), { method:'POST', headers:getHeaders() });
      if (r.ok) { M.toast({html:'All claimed'}); await load(); if (selectedId) openMemo(selectedId); return; }
    } catch {}

    let pageNum = 1, hasNext = true, claimed = 0, pageSize = 50;
    while (hasNext && pageNum <= 50) {
      const q = buildQuery(pageNum, pageSize);
      const res = await fetch(API(`/memos?${q.toString()}`), { headers:getHeaders() });
      if (!res.ok) break;
      const json = await res.json().catch(()=>({}));
      const items = json.data || json.items || [];
      hasNext = (json.pageInfo && json.pageInfo.hasNext) || (items.length === pageSize);
      pageNum++;

      for (const m of items) {
        const expired = m.expiresAt && new Date(m.expiresAt).getTime() <= Date.now();
        const claimedFlag = !!(m.claimedAt || m.claimedBy || (m.attachments && m.attachments.claimed === true));
        const hasAttachment = Array.isArray(m.attachments) ? m.attachments.length > 0 : !!m.attachments;
        if (hasAttachment && !expired && !claimedFlag) {
          try { const r = await fetch(API(`/memos/${m._id}/claim`), { method:'POST', headers:getHeaders() }); if (r.ok) claimed++; } catch {}
        }
      }
    }
    M.toast({ html: `Claimed ${claimed}` });
    await load(); if (selectedId) openMemo(selectedId);
  }

async function deleteRead(){
  try {
    const r = await fetch(API('/memos/delete-read'), { method:'DELETE', headers:getHeaders() });
    if (r.ok) { M.toast({html:'Deleted read memos'}); await refreshUnreadBadge(true); return; }
  } catch {}

  let pageNum = 1, hasNext = true, deleted = 0, pageSize = 50;
  while (hasNext && pageNum <= 50) {
    const q = buildQuery(pageNum, pageSize);
    q.set('status','read');
    const res = await fetch(API(`/memos?${q.toString()}`), { headers:getHeaders() });
    if (!res.ok) break;
    const json = await res.json().catch(()=>({}));
    const items = json.data || json.items || [];
    hasNext = (json.pageInfo && json.pageInfo.hasNext) || (items.length === pageSize);
    pageNum++;

    for (const m of items) {
      try { const r = await fetch(API(`/memos/${m._id}`), { method:'DELETE', headers:getHeaders() }); if (r.ok) deleted++; } catch {}
    }
  }
  M.toast({ html: `Deleted ${deleted} read memos` });
  await refreshUnreadBadge(true);
}

  // utils
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));}
  function parseJsonOrNull(s){ try{ return s?JSON.parse(s):null }catch(_){ return null } }
  function debounce(fn, delay){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a),delay); }; }
</script>

</body>
</html>
